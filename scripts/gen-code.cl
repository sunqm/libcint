;;;;
;;;; File: gen-code.cl
;;;; Author: Qiming Sun <osirpt.sun@gmail.com>
;;;; Description:
;;;  dump to output file

(load "utility.cl")
(load "parser.cl")
(load "derivator.cl")

; TODO
;
;(defun gen-raw-output (foutput vs1 &optional vs2)
;  (format foutput "~%e1:")
;  (format foutput "~a" vs1)
;  (format foutput "~%e2:")
;  (format foutput "~a" vs2))
;
;(defun gen-tex-subscript (foutput vs1 &optional vs2)
;  (defun tex-subscript-filter (cell)
;    (format foutput "~a,~{~a~},~{~a~} "
;            (phase-of cell)
;            (scripts-of (consts-of cell))
;            (scripts-of (ops-of cell))))
;  (gen-subscript (set-cells-streamer #'tex-subscript-filter foutput)
;                 (tensor-of-cellss vs1 vs2)))
;
;(defun gen-ternary-subscript (foutput vs1 &optional vs2)
;  (defun ternary-filter (cell)
;    (format foutput "~a,~a,~a "
;            (phase-of cell)
;            (ternary-subscript (consts-of cell))
;            (ternary-subscript (ops-of cell))))
;  (gen-subscript (set-cells-streamer #'ternary-filter foutput)
;                 (tensor-of-cellss vs1 vs2)))

(defun gen-subscript (cells-streamer raw-script)
  (labels ((gen-tex-iter (raw-script)
             (cond ((null raw-script) raw-script)
                   ((vector? raw-script)
                    (gen-tex-iter (comp-x raw-script))
                    (gen-tex-iter (comp-y raw-script))
                    (gen-tex-iter (comp-z raw-script)))
                   ((cells? raw-script)
                    (funcall cells-streamer raw-script))
                   (t (mapcar cells-streamer raw-script)))))
    (gen-tex-iter raw-script)))

(defun convert-from-n-sys (ls n)
  (reduce (lambda (x y) (+ (* x n) y)) ls
          :initial-value 0))

(defun xyz-to-ternary (xyzs)
  (cond ((eql xyzs 'x) 0)
        ((eql xyzs 'y) 1)
        ((eql xyzs 'z) 2)
        (t (error " unknown subscript ~a" xyzs))))

(defun ternary-subscript (ops)
  "convert the polynomial xyz to the ternary"
  (cond ((null ops) ops)
        (t (convert-from-n-sys (mapcar #'xyz-to-ternary 
                                       (remove-if (lambda (x) (eql x 's))
                                                  (scripts-of ops)))
                               3))))
(defun gen-c-block (fout fmt-gout raw-script)
  (let ((ginc -1))
    (labels ((c-filter (cell)
               (let ((fac (realpart (phase-of cell)))
                     (const@3 (ternary-subscript (consts-of cell)))
                     (op@3    (ternary-subscript (ops-of cell))))
                 (cond ((null const@3)
                        (if (null op@3)
                          (format fout " + (~a*s\[0\])" fac)
                          (format fout " + (~a*s\[~a\])"
                                  fac op@3)))
                       ((null op@3)
                        (format fout " + (~a*c\[~a\]*s\[0\])"
                                fac const@3))
                       (t (format fout " + (~a*c\[~a\]*s\[~a\])"
                                  fac const@3 op@3)))))
             (c-streamer (cs)
               (format fout fmt-gout (incf ginc))
               (cond ((null cs) (format fout " 0"))
                     ((cell? cs) (c-filter cs))
                     (t (mapcar #'c-filter cs)))
               (format fout ";~%")))
      (gen-subscript #'c-streamer raw-script)
      (1+ ginc))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; effective keys are p,r,ri,...
(defun effect-keys (ops)
  (remove-if-not (lambda (x)
                   (member x (append '(nabla-rinv nabla-r12)
                                     *intvar-keywords*)))
                 ops))
(defun g?e-of (key)
  (case key
    ((p ip nabla px py pz) "D_")
    ((r x y z) "R_") ; the vector origin is on the center of the basis it acts on
    ((ri rj rk rl) "RC") ; the vector origin is R[ijkl]
    ((r0 g) "R0") ; R0 ~ the vector origin is (0,0,0)
    ((rc) "RC") ; the vector origin is set in env[PTR_COMMON_ORIG]
    ((nabla-rinv nabla-r12) "D_")
    (otherwise (error "unknown key ~a" key))))

(defun dump-header (fout)
  (format fout "/*
 * File:
 * Author: Qiming Sun <osirpt.sun@gmail.com>
 * Description: code generated by  gen-code.cl
 */
#include \"cint_bas.h\"
#include \"cart2sph.h\"
#include \"g2e.h\"
#include \"optimizer.h\"
#include \"cint1e.h\"
#include \"cint2e.h\"
#include \"misc.h\"
#include \"fblas.h\"
#include \"c2f.h\"
"))

(defun dump-declare-dri-for-rc (fout i-ops symb)
  (when (member 'rc i-ops)
    (format fout "double dr~a[3];~%" symb)
    (format fout "dr~a[0] = r~a[0] - env[PTR_COMMON_ORIG+0];~%" symb symb)
    (format fout "dr~a[1] = r~a[1] - env[PTR_COMMON_ORIG+1];~%" symb symb)
    (format fout "dr~a[2] = r~a[2] - env[PTR_COMMON_ORIG+2];~%" symb symb))
  (when (member 'ri i-ops)
    (format fout "double dr~a[3];~%" symb)
    (format fout "dr~a[0] = r~a[0] - ri[0];~%" symb symb)
    (format fout "dr~a[1] = r~a[1] - ri[1];~%" symb symb)
    (format fout "dr~a[2] = r~a[2] - ri[2];~%" symb symb))
  (when (member 'rj i-ops)
    (format fout "double dr~a[3];~%" symb)
    (format fout "dr~a[0] = r~a[0] - rj[0];~%" symb symb)
    (format fout "dr~a[1] = r~a[1] - rj[1];~%" symb symb)
    (format fout "dr~a[2] = r~a[2] - rj[2];~%" symb symb))
  (when (member 'rk i-ops)
    (format fout "double dr~a[3];~%" symb)
    (format fout "dr~a[0] = r~a[0] - rk[0];~%" symb symb)
    (format fout "dr~a[1] = r~a[1] - rk[1];~%" symb symb)
    (format fout "dr~a[2] = r~a[2] - rk[2];~%" symb symb))
  (when (member 'rl i-ops)
    (format fout "double dr~a[3];~%" symb)
    (format fout "dr~a[0] = r~a[0] - rl[0];~%" symb symb)
    (format fout "dr~a[1] = r~a[1] - rl[1];~%" symb symb)
    (format fout "dr~a[2] = r~a[2] - rl[2];~%" symb symb)))

(defun dump-declare-giao-ij (fout bra ket)
  (let ((n-giao (count 'g (append bra ket))))
    (when (> n-giao 0)
      (format fout "double rirj[3], c[~a];~%" (expt 3 n-giao))
      (format fout "rirj[0] = ri[0] - rj[0];~%" )
      (format fout "rirj[1] = ri[1] - rj[1];~%" )
      (format fout "rirj[2] = ri[2] - rj[2];~%" )
      (loop
        for i upto (1- (expt 3 n-giao)) do
        (format fout "c[~a] = 1" i)
        (loop
          for j from (1- n-giao) downto 0
          and res = i then (multiple-value-bind (int res) (floor res (expt 3 j))
                             (format fout " * rirj[~a]" int)
                             res))
        (format fout ";~%")))))

; l-combo searches op_bit from left to right
;  o100 o010 o001|g...>  =>  |g...> = o100 |g0..>
;  |g100,l> = o100 |g000,l+1>
;  |g101,l> = o100 |g001,l+1>
;  |g110,l> = o100 |g010,l+1>
;  |g111,l> = o100 |g011,l+1>
; r-combo searches op_bit from right to left
;  o100 o010 o001|g...>  =>  |g...> = o001 |g..0>
;  |g100,l+2> = o100 |g000,l+3>
;  |g101,l  > = o001 |g100,l+1>
;  |g110,l+1> = o010 |g100,l+2>
;  |g111,l  > = o001 |g110,l+1>
; [lr]-combo have no connection with <bra| or |ket>
;    def l_combinator(self, ops, ig, mask, template):
(defun first-bit1 (n)
  (loop
    for i upto 31
    thereis (if (zerop (ash n (- i))) (1- i))))
(defun last-bit1 (n)
  (loop
    for i upto 31
    thereis (if (oddp (ash n (- i))) i)))
(defun combo-bra (fout fmt ops-rev n-ops ig mask)
  (let* ((right (first-bit1 (ash ig (- mask))))
         (left (- n-ops right 1))
         (ig0 (- ig (ash 1 (+ mask right))))
         (op (nth right ops-rev)))
    (format fout fmt (g?e-of op) ig ig0 left)))
(defun combo-opj (fout fmt-op fmt-j opj-rev j-len ig mask)
  (let ((right (last-bit1 (ash ig (- mask)))))
    (if (< right j-len) ; does not reach op yet
      (combo-ket fout fmt-j opj-rev ig mask)
      (let ((ig0 (- ig (ash 1 (+ mask right))))
            (op (nth right opj-rev)))
        (if (member op '(nabla-rinv nabla-r12))
          (format fout fmt-op
                  (g?e-of op) ig ig0 right
                  (g?e-of op) (1+ ig) ig0 right
                  (1+ ig) ig)
          (format fout fmt-j (g?e-of op) ig ig0 right))))))
(defun combo-ket (fout fmt ops-rev ig mask)
  (let* ((right (last-bit1 (ash ig (- mask))))
         (ig0 (- ig (ash 1 (+ mask right))))
         (op (nth right ops-rev)))
    (format fout fmt (g?e-of op) ig ig0 right)))

(defun power2-range (n &optional (shift 0))
  (range (+ shift (ash 1 n)) (+ shift (ash 1 (1+ n)))))
(defun dump-combo-braket (fout fmt-i fmt-op fmt-j i-rev op-rev j-rev mask)
  (let* ((i-len (length i-rev))
         (j-len (length j-rev))
         (op-len (length op-rev))
         (opj-rev (append j-rev op-rev)))
    (loop
      for right from mask to (+ mask j-len op-len -1) do
      (loop
        for ig in (power2-range right) do
        (combo-opj fout fmt-op fmt-j opj-rev j-len ig mask)))
    (let ((shft (+ op-len j-len mask)))
      (loop
        for right from shft to (+ shft i-len -1) do
        (loop
          for ig in (power2-range right) do
          (combo-bra fout fmt-i i-rev i-len ig shft))))))

(defun dec-to-ybin (n)
  (parse-integer (substitute #\0 #\2 (write-to-string n :base 3))
                 :radix 2))
(defun dec-to-zbin (n)
  (parse-integer (substitute #\1 #\2
                             (substitute #\0 #\1
                                         (write-to-string n :base 3)))
                 :radix 2))
(defun dump-s-1e (fout n)
  (format fout "for (n = 0; n < nf; n++) {
ix = idx[n];
iy = idy[n];
iz = idz[n];~%")
  (loop
    for i upto (1- (expt 3 n)) do
    (let* ((ybin (dec-to-ybin i))
           (zbin (dec-to-zbin i))
           (xbin (- (ash 1 n) 1 ybin zbin)))
      (format fout "s[~a] = g~a[ix] * g~a[iy] * g~a[iz];~%"
              i xbin ybin zbin))))

(defun name-c2sor (sfx sp sf ts)
  (cond ((eql sp 'spinor)
         (if (eql sf 'sf)
           (if (eql ts 'ts)
             (format nil "&c2s_sf_~a" sfx)
             (format nil "&c2s_sf_~ai" sfx))
           (if (eql ts 'ts)
             (format nil "&c2s_si_~a" sfx)
             (format nil "&c2s_si_~ai" sfx))))
         ((eql sp 'spheric)
          (format nil "&c2s_sph_~a" sfx))
         (t (format nil "&c2s_cart_~a" sfx))))

(defun gen-code-int1e (fout intname raw-infix &optional (sp 'spinor))
  (destructuring-bind (op bra-i ket-j bra-k ket-l)
    (split-int-expression raw-infix)
    (let* ((i-rev (effect-keys bra-i)) ;<i| already in reverse order
           (j-rev (reverse (effect-keys ket-j)))
           (op-rev (reverse (effect-keys op)))
           (i-len (length i-rev))
           (j-len (length j-rev))
           (op-len (length op-rev))
           (tot-bits (+ i-len j-len op-len))
           (raw-script (eval-int raw-infix))
           (ts (car raw-script))
           (sf (cadr raw-script))
           (goutinc))
      (format fout "/* <~{~a ~}i|~{~a ~}|~{~a ~}j> */~%" bra-i op ket-j)
      (format fout "static void CINTgout1e_~a(double *g, const unsigned int *ng,
double *gout, const unsigned int nf, const unsigned int *idx,
const double ai, const double aj,
const unsigned int *shls,
const int *atm, const int *bas, const double *env) {~%" intname)
      (format fout "const unsigned int INC1 = 1;
const double D1 = 1;
const int i_sh = shls[0];
const int j_sh = shls[1];
const unsigned int i_l = (unsigned int)bas(ANG_OF, i_sh);
const unsigned int j_l = (unsigned int)bas(ANG_OF, j_sh);
const unsigned int *idy = idx + nf;
const unsigned int *idz = idx + nf * 2;
const double *ri = env + atm(PTR_COORD, bas(ATOM_OF, i_sh));
const double *rj = env + atm(PTR_COORD, bas(ATOM_OF, j_sh));
unsigned int ix, iy, iz, n;
double *g0 = g;~%")
      (loop
        for i in (range (ash 1 tot-bits)) do
        (format fout "double *g~a = g~a  + ng[0] * ng[1] * 3;~%" (1+ i) i))
      (format fout "double s[~a];~%" (expt 3 tot-bits))
      (dump-declare-dri-for-rc fout bra-i "i")
      (dump-declare-dri-for-rc fout (append op ket-j) "j")
      (dump-declare-giao-ij fout bra-i (append op ket-j))
;;; generate g_(bin)
;;; for the operators act on the |ket>, the reversed scan order and r_combinator
;;; is required; for the operators acto on the <bra|, the normal scan order and
      (let ((fmt-i (mkstr "G1E_~aI(g~a, g~a, i_l+~a, j_l);~%"))
            (fmt-op (mkstr "G1E_~aJ(g~a, g~a, i_l+" i-len ", j_l+~a);
G1E_~aI(g~a, g~a, i_l+" i-len ", j_l+~a);
n = ng[0] * ng[1] * 3;
daxpy_(&n, &D1, g~a, &INC1, g~a, &INC1);~%"))
            (fmt-j (mkstr "G1E_~aJ(g~a, g~a, i_l+" i-len ", j_l+~a);~%")))
        (dump-combo-braket fout fmt-i fmt-op fmt-j i-rev op-rev j-rev 0))
;;; generate gout
      (dump-s-1e fout tot-bits)
;;; dump result of eval-int
      (setf goutinc (gen-c-block fout "gout[~a] +=" (last1 raw-script)))
      (format fout "gout += ~a;~%}}~%" goutinc)
;;; generate function int1e
      (format fout "int ~a(double *opij, const unsigned int *shls,
const int *atm, const int natm,
const int *bas, const int nbas, const double *env) {~%" intname)
      (format fout "const int i_sh = shls[0];
const int j_sh = shls[1];
const int i_l = (unsigned int)bas(ANG_OF, i_sh);
const int j_l = (unsigned int)bas(ANG_OF, j_sh);
unsigned int ng[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};~%")
      (format fout "ng[1] = j_l + ~a + 1;~%" (+ op-len j-len))
      (format fout "ng[0] = i_l + ~a + ng[1];~%" i-len)
      (format fout "ng[GSHIFT] = ~a;~%" tot-bits)
      (if (eql sf 'sf)
        (progn (format fout "ng[POS_E1] = 1;~%")
               (format fout "ng[TENSOR] = ~a;~%" goutinc))
        (progn (format fout "ng[POS_E1] = 4;~%")
               (format fout "ng[TENSOR] = ~a;~%" (/ goutinc 4))))
;;; determine factor
      (when (member 'g raw-infix)
        (format fout "if (bas(ATOM_OF, i_sh) == bas(ATOM_OF, j_sh)) {~%")
        (if (eql sp 'spinor)
           (format fout "int ip = CINTlen_spinor(i_sh, bas) * bas(NCTR_OF,i_sh);
int jp = CINTlen_spinor(j_sh, bas) * bas(NCTR_OF,j_sh);
CINTdset0(ip * jp * OF_CMPLX * ng[TENSOR], opij);~%")
           (format fout "int ip = (i_l * 2 + 1) * bas(NCTR_OF,i_sh);
int jp = (j_l * 2 + 1) * bas(NCTR_OF,j_sh);
CINTdset0(ip * jp * ng[TENSOR], opij);~%"))
        (format fout "return 0; }~%"))
;;; determine function caller
      (let ((intdrv (cond ((member 'nuc raw-infix) "CINT1e_nuc_drv")
                          ((or (member 'rinv raw-infix)
                               (member 'nabla-rinv raw-infix))
                           "CINT1e_rinv_drv")
                          (t "CINT1e_drv")))
            (rfac (factor-of raw-infix))
            (c2sor (name-c2sor "1e" sp sf ts)))
        (format fout "return ~a(opij, ng, ~a,~%" intdrv rfac)
        (format fout "CINTgout1e_~a, ~a,~%" intname c2sor)
        (format fout "shls, atm, natm, bas, nbas, env); }~%C2F_(~a)~%" intname)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun dump-declare-giao-ijkl (fout opi opj opk opl)
  (let ((n-ij (count 'g (append opi opj)))
        (n-kl (count 'g (append opk opl))))
    (when (> n-ij 0)
      (format fout "double rirj[3];~%")
      (format fout "rirj[0] = ri[0] - rj[0];~%" )
      (format fout "rirj[1] = ri[1] - rj[1];~%" )
      (format fout "rirj[2] = ri[2] - rj[2];~%" ))
    (when (> n-kl 0)
      (format fout "double rkrl[3];~%")
      (format fout "rkrl[0] = rk[0] - rl[0];~%" )
      (format fout "rkrl[1] = rk[1] - rl[1];~%" )
      (format fout "rkrl[2] = rk[2] - rl[2];~%" ))
    (when (> (+ n-ij n-kl) 0)
      (format fout "double c[~a];~%" (expt 3 (+ n-ij n-kl)))
      (loop
        for i upto (1- (expt 3 (+ n-ij n-kl))) do
        (format fout "c[~a] = 1" i)
        (loop
          for j from (+ n-ij n-kl -1) downto n-kl
          and res = i then (multiple-value-bind (int res) (floor res (expt 3 j))
                             (format fout " * rirj[~a]" int)
                             res))
        (loop
          for j from (1- n-kl) downto 0
          and res = (nth-value 1 (floor i (expt 3 n-kl)))
                    then (multiple-value-bind (int res) (floor res (expt 3 j))
                           (format fout " * rkrl[~a]" int)
                           res))
        (format fout ";~%")))))

(defun dump-s-2e (fout n)
  (format fout "for (n = 0; n < nf; n++, idx+=3) {
ix = idx[0];
iy = idx[1];
iz = idx[2];
CINTdset0(~a, s);
for (i = 0; i < envs->nrys_roots; i++) {~%" (expt 3 n))
  (loop
    for i upto (1- (expt 3 n)) do
    (let* ((ybin (dec-to-ybin i))
           (zbin (dec-to-zbin i))
           (xbin (- (ash 1 n) 1 ybin zbin)))
      (format fout "s[~a] += g~a[ix+i] * g~a[iy+i] * g~a[iz+i];~%"
              i xbin ybin zbin)))
  (format fout "}~%")) ; end do i = 1, envs->nrys_roots

(defun gen-code-int2e (fout intname raw-infix &optional (sp 'spinor))
  (destructuring-bind (op bra-i ket-j bra-k ket-l)
    (split-int-expression raw-infix)
    (let* ((i-rev (effect-keys bra-i))
           (j-rev (reverse (effect-keys ket-j)))
           (k-rev (effect-keys bra-k))
           (l-rev (reverse (effect-keys ket-l)))
           (op-rev (reverse (effect-keys op)))
           (i-len (length i-rev))
           (j-len (length j-rev))
           (k-len (length k-rev))
           (l-len (length l-rev))
           (op-len (length op-rev))
           (tot-bits (+ i-len j-len op-len k-len l-len))
           (raw-script (eval-int raw-infix))
           (ts1 (car raw-script))
           (sf1 (cadr raw-script))
           (ts2 (caddr raw-script))
           (sf2 (cadddr raw-script))
           (goutinc))
      (format fout "/* <~{~a ~}k ~{~a ~}i|~{~a ~}|~{~a ~}j ~{~a ~}l> : i,j\in electron 1; k,l\in electron 2~%"
              bra-k bra-i op ket-j ket-l)
      (format fout " * = (~{~a ~}i ~{~a ~}j|~{~a ~}|~{~a ~}k ~{~a ~}l) */~%"
              bra-i ket-j op bra-k ket-l)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; generate function gout2e
      (format fout "static void CINTgout2e_~a(double *g,
double *gout, const unsigned int *idx, const CINTEnvVars *envs, int gout_empty) {~%" intname)
      (format fout "const unsigned int INC1 = 1;
const double D1 = 1;
const double *env = envs->env;
const unsigned int nf = envs->nf;
const unsigned int i_l = envs->i_l;
const unsigned int j_l = envs->j_l;
const unsigned int k_l = envs->k_l;
const unsigned int l_l = envs->l_l;
const double *ri = envs->ri;
const double *rj = envs->rj;
const double *rk = envs->rk;
const double *rl = envs->rl;
unsigned int ix, iy, iz, i, n;
double *g0 = g;~%")
      (loop
        for i in (range (ash 1 tot-bits)) do
        (format fout "double *g~a = g~a + envs->g_size * 3;~%" (1+ i) i))
      (format fout "double s[~a];~%" (expt 3 tot-bits))
      (dump-declare-dri-for-rc fout bra-i "i")
      (dump-declare-dri-for-rc fout ket-j "j")
      (dump-declare-dri-for-rc fout bra-k "k")
      (dump-declare-dri-for-rc fout ket-l "l")
      (dump-declare-giao-ijkl fout bra-i ket-j bra-k ket-l)
;;; generate g_(bin)
      (let ((fmt-k (mkstr "G2E_~aK(g~a, g~a, i_l+" i-len ", j_l+" j-len
                          ", k_l+~a, l_l);~%"))
            (fmt-op "")
            (fmt-l (mkstr "G2E_~aL(g~a, g~a, i_l+" i-len ", j_l+" j-len
                          ", k_l+" k-len ", l_l+~a);~%")))
        (dump-combo-braket fout fmt-k fmt-op fmt-l k-rev op-rev l-rev 0))
      (let ((fmt-i (mkstr "G2E_~aI(g~a, g~a, i_l+~a, j_l, k_l, l_l);~%"))
            (fmt-op (mkstr "G2E_~aJ(g~a, g~a, i_l+" i-len ", j_l+~a, k_l, l_l);
G2E_~aI(g~a, g~a, i_l+" i-len ", j_l+~a, k_l, l_l);
n = envs->g_size * 3;
daxpy_(&n, &D1, g~a, &INC1, g~a, &INC1);~%"))
            (fmt-j (mkstr "G2E_~aJ(g~a, g~a, i_l+" i-len ", j_l+~a, k_l, l_l);~%")))
        (dump-combo-braket fout fmt-i fmt-op fmt-j i-rev op-rev j-rev (+ k-len l-len)))
      (format fout "if (gout_empty) {~%")
;;; generate gout
      (dump-s-2e fout tot-bits)
;;; dump result of eval-int
      (setf goutinc (gen-c-block fout "gout[~a] =" (last1 raw-script)))
      (format fout "gout += ~a;~%}} else {~%" goutinc)
      (dump-s-2e fout tot-bits)
;;; dump result of eval-int
      (setf goutinc (gen-c-block fout "gout[~a] +=" (last1 raw-script)))
      (format fout "gout += ~a;~%}}}~%" goutinc)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; generate optimizer for function int2e
      (format fout "void ~a_optimizer(CINTOpt **opt, const int *atm, const int natm,
const int *bas, const int nbas, const double *env) {~%" intname)
      (format fout "unsigned int ng[] = {~d, ~d, ~d, ~d, 0, 0, 0, 0, 0};~%"
              i-len j-len k-len (+ op-len l-len))
      (format fout "CINTuse_all_optimizer(opt, ng, atm, natm, bas, nbas, env);~%}~%")
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; generate function int2e
      (format fout "int ~a(double *opkijl, const unsigned int *shls,
const int *atm, const int natm,
const int *bas, const int nbas, const double *env, CINTOpt *opt) {~%" intname)
      (format fout "unsigned int ng[] = {~d, ~d, ~d, ~d, 0, ~d, ~d, ~d, ~d};~%"
              i-len j-len k-len (+ op-len l-len) tot-bits
              (if (eql sf1 'sf) 1 4) (if (eql sf2 'sf) 1 4)
              (cond ((and (eql sf1 'sf) (eql sf2 'sf)) goutinc)
                    ((and (eql sf1 'si) (eql sf2 'si)) (/ goutinc 16))
                    (t (/ goutinc 4))))
;;; determine factor
      (when (member 'g raw-infix)
        (format fout "const unsigned int i_sh = shls[0];
const unsigned int j_sh = shls[1];
const unsigned int k_sh = shls[2];
const unsigned int l_sh = shls[3];~%")
        (let ((set0sph "unsigned int ip = (bas(ANG_OF,i_sh) * 2 + 1) * bas(NCTR_OF,i_sh);
unsigned int jp = (bas(ANG_OF,j_sh) * 2 + 1) * bas(NCTR_OF,j_sh);
unsigned int kp = (bas(ANG_OF,k_sh) * 2 + 1) * bas(NCTR_OF,k_sh);
unsigned int lp = (bas(ANG_OF,l_sh) * 2 + 1) * bas(NCTR_OF,l_sh);
CINTdset0(kp * ip * jp * lp * ng[TENSOR], opkijl);")
              (set0spin "unsigned int ip = CINTlen_spinor(i_sh, bas) * bas(NCTR_OF,i_sh);
unsigned int jp = CINTlen_spinor(j_sh, bas) * bas(NCTR_OF,j_sh);
unsigned int kp = CINTlen_spinor(k_sh, bas) * bas(NCTR_OF,k_sh);
unsigned int lp = CINTlen_spinor(l_sh, bas) * bas(NCTR_OF,l_sh);
CINTdset0(kp * ip * jp * lp * OF_CMPLX * ng[TENSOR], opkijl);"))
        (when (or (member 'g bra-i) (member 'g ket-j))
          (format fout "if (bas(ATOM_OF, i_sh) == bas(ATOM_OF, j_sh)) {
~a~%return 0; }~%" (if (eql sp 'spinor) set0spin set0sph)))
        (when (or (member 'g bra-k) (member 'g ket-l))
          (format fout "if (bas(ATOM_OF, k_sh) == bas(ATOM_OF, l_sh)) {
~a~%return 0; }~%" (if (eql sp 'spinor) set0spin set0sph)))))
;;; initialize CINTEnvVars
      (format fout "CINTEnvVars envs;
CINTinit_int2e_EnvVars(&envs, ng, shls, atm, natm, bas, nbas, env);~%")
      (format fout "envs.f_gout = &CINTgout2e_~a;~%" intname)
      (format fout "envs.common_factor *= ~a;~%" (factor-of raw-infix))
;;; determine function caller
      (cond ((eql sp 'spinor)
             (format fout "return CINT2e_spinor_drv(opkijl, &envs, opt, ~a, ~a);~%}~%"
                     (name-c2sor "2e1" sp sf1 ts1)
                     (name-c2sor "2e2" sp sf2 ts2)))
            ((eql sp 'spheric)
             (format fout "return CINT2e_spheric_drv(opkijl, &envs, opt);~%}~%"))
            ((eql sp 'cart)
             (format fout "return CINT2e_cart_drv(opkijl, &envs, opt);~%}~%")))
      (format fout "OPTIMIZER2F_(~a_optimizer);~%C2Fo_(~a)~%"
              intname intname))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun gen-cint (filename sp &rest items)
  "sp can be one of 'spinor 'spheric 'cart"
  (if (not (member sp '(spinor spheric cart)))
    (error "gen-cint: unknown ~a . sp can be one of 'spinor 'spheric 'cart" sp))
  (with-open-file (fout (mkstr filename)
                        :direction :output :if-exists :supersede)
    (dump-header fout)
    (flet ((gen-code (item)
      (let ((intname (mkstr (car item)))
            (raw-infix (cadr item)))
        (if (one-electron-int? raw-infix)
          (gen-code-int1e fout intname raw-infix sp)
          (gen-code-int2e fout intname raw-infix sp)))))
      (mapcar #'gen-code items))))

; gcl -load sigma.o -batch -eval "( .. )"

;; vim: ft=lisp
