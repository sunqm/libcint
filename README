libcint
=======

version 2.0.7
2014-10-16


What is libcint
---------------

libcint is an open source library for computation of Gaussian type
integrals.  It provides C/Fortran function to evaluate one-electron /
two-electron integrals for Cartesian / real-spheric / spinor Gaussian type
functions.


Features
--------

* Various GTO type:
  - Cartesian GTO:  s, p, 6d, 10f, 15g, 21h Gaussian type functions.
  - Real-spheric GTO:  s, p, 5d, 7f, 9g, 11h Gaussian type functions.
  - Spinor GTO:  J-adapted spinor Gaussian functions.
* One electron integrals.
  - Regular kinetic-like integrals.
  - Nuclear attraction-like integrals (Gaussian nuclear model are supported).
* Two electron integrals (value < 1e-15 are neglected) include
  - Coulomb repulsion
  - Gaunt interaction
* Common lisp script to generate C code for new integrals.
* Thread safe.
* Uniform API for all kind of integrals.
  - one electron integrals
    not0 = fn1e_name(double *buf, int *atm, int natm, int *bas, int nbas, double *env);
  - two electron integrals
    not0 = fn2e_name(double *buf, int *atm, int natm, int *bas, int nbas, double *env, NULL);
  - the return boolean (not0) gives the summary whether the integrals
    are completely 0.
* Minimal overhead of initialization
  - Pre-comuptation is not required.  Only basic info (see previous API)
    of basis function need to be initialized, within a plain integer or
    double precision array.  (For 2e integral, there is an optional
    argument called optimizer which can be switched off by setting it to
    NULL.  Using optimizer should not affect the value of integral, but
    can increase the performance by ~10%.)
* Minimal dependence on external library.
  - BLAS is the only library needed.  Normally, the performance
    difference due to various BLAS implementations is less than 1%.
* Small memory usage.
  - Very few intermediate data are stored.  ~80% of the memory are
    allocated for holding the whole contracted Cartesion integrals,
    which typically should be less than 1 Mega bytes.


Getting libcint
---------------

The newest version is available on GitHub:

    git clone http://github.com/sunqm/libcint.git


Generating integrals
--------------------

If clisp was installed in the system, new integrals can be automatically
implemented.  You can add entries in script/auto_intor.cl and generate
code by

    cd script; clisp auto_intor.cl; mv *.c ../src/autocode/

New entries should follow the format of those existed entries.
In one entry, you need to define the function name and the expression of
the integral.  The expression is consistent with Mulliken notation.
For one-electron integral, an entry can be

    '("integral_name" (number op-bra op-bra ... \| op-ket ...))
or
    '("integral_name" (number op-bra op-bra ... \| 1e-operator \| op-ket ...))

the entry of two-electron integral can be

    '("integral_name" (number op-bra-electron-1 ... \, op-ket-electron-1 ... \|
                              op-bra-electron-2 ... \, op-ket-electron-2 ... ))
or
    '("integral_name" (number op-bra-electron-1 ... \, op-ket-electron-1 ... \|
                       gaunt \| op-bra-electron-2 ... \, op-ket-electron-2 ... ))

* Parentheses must be paired.
* Line break is allowed.
* Note the _backslash_ in \| and \ is required.
* "integral_name" is the function name.  Valid name can be made up of
  letters, digits and underscore ("_").
* number can be an integer, a real number or a pure imaginary number. An
  imaginary number should be written as
    #C(0 XXX)
* Supported operator-bra and operator-ket include
    p     means    -i \nabla
    ip    means    \nabla
    r0    means    \vec{r} - (0,0,0)
    rc    means    \vec{r} - \vec{R}_(env[PTR_COMMON_ORIG])
    ri    means    \vec{r} - \vec{R}_i
    rj    means    \vec{r} - \vec{R}_j
    rk    means    \vec{r} - \vec{R}_k
    rl    means    \vec{r} - \vec{R}_l
    r              can be ri/rj/rk/rl; associate with the basis it operates
    g     means    i/2 (\vec{R}_{bra} - \vec{R}_{ket}) \times \vec{r}
    sigma means    three pauli matrix
    dot, cross     can be used to combine operator-bra or operator-ket
* Supported 1e-operator and 2e-operator include
    rinv        means   1 / |\vec{r} - \vec{R}_(env[PTR_RINV_ORIG])|
    nuc         means   \sum_N Z_N / |\vec{r} - \vec{R}_N|
    nabla-rinv  means   \nabla (1 / |\vec{r} - \vec{R}_(env[PTR_RINV_ORIG])|)
    gaunt       means   \alpha_i \dot \alpha_j / |\vec{r}_i - \vec{r}_j|


Installation
------------

* Prerequisites
    - BLAS library
    - Python version 2.5 or higher (optional, for make check)
    - clisp / SBCL (optional, for common lisp script)

* Build libcint
    mkdir build; cd build
    ../configure <options>
    make
    make install

* Use Intel MKL as BLAS library
    - MKL version 10.2 or older or CPU without Intel AVX instruction
      ../configure --with-blas="-Wl,--start-group -L$MKLROOT/lib/intel64 \
          -lmkl_intel_lp64 -lmkl_sequential -lmkl_core \
          -Wl,--end-group -lpthread"
    - MKL version 10.3 or newer and CPU with Intel AVX instruction
      ../configure --with-blas="-Wl,--start-group -L$MKLROOT/lib/intel64 \
          -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lmkl_avx \
          -Wl,--end-group -lpthread"
    - Link flags of other MKL version refers to the online MKL link advisor
      http://software.intel.com/sites/products/mkl/


Known problems
--------------

* On 64-bit system, "make check" stop with error:

    MKL FATAL ERROR: Cannot load libmkl_avx.so or libmkl_def.so.

  This problem is caused by the conflict between Python and MKL library.
  It can be fixed by adding -lmkl_avx or -lmkl_mc -lmkl_def to MKL link
  flags to replace the default blas link flags.  Be careful with the
  *order* of -lmkl_mc and -lmkl_def.  e.g.
    ../configure --with-blas="-Wl,--start-group -L$MKLROOT/lib/intel64 \
        -lmkl_intel_lp64 -lmkl_sequential -lmkl_core -lmkl_mc -lmkl_def \
        -Wl,--end-group -lpthread"

* For plain ERI, the code can handle highest angular momentum up to 6
  (present Rys-roots functions might be numerically unstable for l=5,6).
  But it has to be reduced to 5 or less for derivative or high order ERI.
  Depending on the derivative order, reduce 1 highest angular momentum
  every 4 derivative order.

* If stack size < 6.5 MB, Segmentation fault may occur in function
  c2s_sph_2e1 for angular momentum l=6

* For portability, SSE instructions was not applied in this version.
  Using SSE3 instructions can increase the performance 5 ~ 50%.
  Please contact the author for the Libcint(SSE3) code.


Bug report
----------
Qiming Sun <osirpt.sun@gmail.com>
